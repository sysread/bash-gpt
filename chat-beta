#!/usr/bin/env bash

set -eu -o pipefail

# ------------------------------------------------------------------------------
# Params
# ------------------------------------------------------------------------------
PROGRAM="${0##*/}"
STORE="$HOME/.bashgpt/chat"
CHAT_HISTORY_FILE="$STORE/chat-history"
LAST_ASSISTANT_FILE="$STORE/last_assistant.conf"

# ------------------------------------------------------------------------------
# Globals
# ------------------------------------------------------------------------------
ASSISTANT_NAME=""
ASSISTANT_ID=""
THREAD_ID=""
THREAD_LABEL=""
MESSAGE_ID=""

# ------------------------------------------------------------------------------
# Functions
# ------------------------------------------------------------------------------
validate-env() {
  local tools=("curl" "jq" "gum" "openai")
  local cmd

  for cmd in "${tools[@]}"; do
    if ! command -v "$cmd" &> /dev/null; then
      echo "$cmd is not installed" >&2

      if [ "$cmd" == "openai" ]; then
        echo " - $cmd is a beta tool provided by this project." >&2
        echo ' - You can make it available by putting it on your PATH' >&2
        # shellcheck disable=SC2016
        echo '      export PATH="$PATH:/path/to/bash-gpt"' >&2
      fi

      exit 1
    fi
  done

  if [ -z "${OPENAI_API_KEY:-}" ]; then
    die "OPENAI_API_KEY is not set in the environment"
  elif [[ ! "$OPENAI_API_KEY" =~ ^sk-[a-zA-Z0-9]{32,64}$ ]]; then
    die "OPENAI_API_KEY is not a valid key"
  fi

  mkdir -p "$STORE"

  touch "$CHAT_HISTORY_FILE"
  touch "$LAST_ASSISTANT_FILE"

  restore-selected-assistant

  return 0
}

info() {
  local msg="$1"
  gum style --foreground="#66FF66" "$PROGRAM: $msg" >&2
}

warn() {
  local msg="${1:-something went wrong}"
  gum style --foreground="#FFFF00" "$PROGRAM: $msg" >&2
}

die() {
  local msg="${1:-something went wrong}"
  gum style --foreground="#FF0000" "$PROGRAM: $msg" >&2
  exit 1
}

# ------------------------------------------------------------------------------
# API calls
# ------------------------------------------------------------------------------
get-completion() {
  local model="$1"
  local system="$2"
  local prompt="$3"
  local result

  if ! result=$(openai get-completion --model "$model" --system "$system" --prompt "$prompt"); then
    warn "error getting completion"
    die "$result"
  fi

  jq -r '.choices[0].message.content' <<< "$result"
}

list-assistants() {
  local result

  if ! result=$(openai list-assistants); then
    warn "error listing assistants"
    die "$result"
  fi

  while IFS=$'\t' read -r id name; do
    echo "$id:$name"
  done < <(jq -r '.data[] | "\(.id)\t\(.name // "null")"' <<< "$result")
}

create-assistant() {
  local name="$1"
  local instructions="$2"
  local description="$3"
  local tools=()
  local tool_args=()

  # gum choose returns a space-separated list of selected tools, so we read it into an array
  IFS=' ' read -r -a tools <<< "$4"

  # Build the tool arguments
  for tool in "${tools[@]}"; do
    [[ -n "$tool" ]] && tool_args+=(--tool "$tool")
  done

  # Now include the tool arguments in the openai invocation
  if ! result=$(openai create-assistant --name "$name" --instructions "$instructions" --description "$description" "${tool_args[@]}" 2>&1); then
    die "$result"
  fi

  jq -r '.id' <<< "$result"
}

modify-assistant() {
  local name="$1"
  local instructions="$2"
  local description="$3"
  local tools=()
  local tool_args=()

  # gum choose returns a space-separated list of selected tools, so we read it into an array
  IFS=' ' read -r -a tools <<< "$4"

  # Build the tool arguments
  for tool in "${tools[@]}"; do
    [[ -n "$tool" ]] && tool_args+=(--tool "$tool")
  done

  # Now include the tool arguments in the openai invocation
  if ! result=$(openai modify-assistant --assistant "$ASSISTANT_ID" --name "$name" --instructions "$instructions" --description "$description" "${tool_args[@]}" 2>&1); then
    die "$result"
  fi

  jq -r '.id' <<< "$result"
}

delete-assistant() {
  local result

  if ! result=$(openai delete-assistant --assistant "$ASSISTANT_ID"); then
    warn "error deleting assistant"
    die "$result"
  fi

  ASSISTANT_ID=""
  ASSISTANT_NAME=""

  return 0
}

start-thread() {
  local result
  local id

  if ! result=$(openai start-thread); then
    warn "error creating a new thread"
    die "$result"
  fi

  jq -r '.id' <<< "$result"
}

send-msg() {
  local msg="$1"
  local result

  if ! result=$(openai add-message --thread "$THREAD_ID" --content "$msg"); then
    warn "error sending message"
    die "$result"
  fi

  MESSAGE_ID=$(jq -r '.id' <<< "$result")
}

# Called in bg proc
# shellcheck disable=2317
run-thread() {
  local result

  if ! result=$(openai run-thread --assistant "$ASSISTANT_ID" --thread "$THREAD_ID"); then
    warn "error running thread"
    die "$result"
  else
    jq -r '.id' <<< "$result"
  fi
}

# Called in bg proc
# shellcheck disable=2317
get-run-status() {
  local run_id="$1"
  local result

  if ! result=$(openai get-run --thread "$THREAD_ID" --run "$run_id"); then
    warn "error getting run"
    die "$result"
  fi

  jq -r '.status' <<< "$result"
}

print-user-msg() {
  local msg="$1"
  local filename

  if [[ "$msg" =~ ^Attached\ file:\ ([^\`]*) ]]; then
    filename=${BASH_REMATCH[1]}

    # Ensure that any potential trailing \n are removed from the filename
    # shellcheck disable=SC2001
    filename=$(echo "$filename" | sed 's/\\n$//')

    # Now utilize awk to truncate any trailing newline escape sequences
    filename=$(echo "$filename" | awk '{ gsub(/\\n/,""); print }')

    msg="Attached file: $filename"
  fi

  gum style --foreground '#66FF66' --bold 'You:'
  gum format "$msg"
}

print-gpt-msg() {
  local msg="$1"
  gum style --foreground '#66CCFF' --bold "$ASSISTANT_NAME:"
  gum format "$msg"
}

list-messages() {
  local limit=${1:-100}
  local get_all=${2:-true}
  local messages
  local role
  local text
  local has_more=true

  while [ "$has_more" == true ]; do
    messages=$(openai list-messages --thread "$THREAD_ID" --order "asc" --after "$MESSAGE_ID" --limit "$limit")
    has_more=$(jq -r '.has_more' <<< "$messages")

    jq -c '.data[] | {role: .role, text: .content[0].text.value}' <<< "$messages" | while IFS= read -r line; do
      MESSAGE_ID=$(jq -r '.id' <<< "$line")

      role=$(jq -r '.role' <<< "$line")
      text=$(jq -r '.text' <<< "$line")

      if [[ "$role" == "user" ]]; then
        print-user-msg "$text"
      else
        print-gpt-msg "$text"
      fi
    done

    if [ "$get_all" == false ]; then
      break
    fi
  done
}

# ------------------------------------------------------------------------------
# Features
# ------------------------------------------------------------------------------
add-assistant() {
  local name
  local instructions
  local description
  local tools

  name=$(gum input --prompt 'Enter a name for the assistant: ' --placeholder 'G. Peetee') || return 0

  [[ -z "$name" ]] && {
    name="G. Peetee"
  }

  instructions=$(
    gum write \
      --width 100 \
      --height 30 \
      --char-limit 0 \
      --placeholder "You are a helpful assistant" \
      --header "GPT instructions" \
      --header.foreground="#66FF66" \
      --cursor.mode=static \
      || true

  )

  [[ -z "$instructions" ]] && {
    instructions="You are a helpful chatbot."
  }

  description=$(gum input --prompt 'Enter an optional description: ' --placeholder 'Gene Peetee, the helpful chatbot.')

  tools="$(gum choose --header 'Select any add-on tools you want available to the assistant' --no-limit {none,code_interpreter,retrieval,function})" || true
  tools=$(echo "$tools" | sed '/^none$/d;/^$/d')

  ASSISTANT_ID=$(create-assistant "$name" "$instructions" "$description" "$tools")
  ASSISTANT_NAME="$name"

  save-selected-assistant
}

edit-assistant() {
  local result

  local name
  local instructions
  local description
  local tools

  local new_name
  local new_instructions
  local new_description
  local new_tools

  if ! result=$(openai get-assistant --assistant "$ASSISTANT_ID"); then
    warn "error getting assistant"
    die "$result"
  fi

  name=$(jq -r '.name' <<< "$result")
  instructions=$(jq -r '.instructions' <<< "$result")
  description=$(jq -r '.description' <<< "$result")
  tools=$(jq -r '.tools | map(.type) | join(" ")' <<< "$result")

  if ! new_name=$(gum input --prompt 'Enter a new name: ' --value "$name"); then
    return
  fi

  if ! new_instructions=$(gum write --width 100 --height 30 --char-limit 0 --value "$instructions" --header "Modify GPT instructions" --header.foreground="#66FF66" --cursor.mode=static); then
    return
  fi

  if ! new_description=$(gum input --prompt 'Modify description: ' --value "$description"); then
    return
  fi

  if ! new_tools=$(gum choose --header 'Update selected tools' --no-limit --selected "$tools" {none,code_interpreter,retrieval,function}); then
    return
  fi

  new_tools=$(echo "$new_tools" | sed '/^none$/d;/^$/d')

  if [ -z "$new_name" ] || [ -z "$new_instructions" ]; then
    # The user pressed escape on name or instructions, so we skip updating the
    # description and tools.
    new_name=$name
    new_instructions=$instructions
  fi

  ASSISTANT_ID=$(modify-assistant "$new_name" "$new_instructions" "$new_description" "$new_tools")
  ASSISTANT_NAME="$new_name"

  save-selected-assistant
}

del-assistant() {
  local old_id="$ASSISTANT_ID"
  local tmp

  gum confirm "Delete assistant $ASSISTANT_NAME (id: $ASSISTANT_ID)?" || return 0
  delete-assistant || return 0

  tmp=$(mktemp)
  if grep -v "^$old_id:" "$CHAT_HISTORY_FILE" > "$tmp"; then
    mv "$CHAT_HISTORY_FILE" "$CHAT_HISTORY_FILE.bak"
    mv "$tmp" "$CHAT_HISTORY_FILE"
    rm "$CHAT_HISTORY_FILE.bak"
  fi
}

save-selected-assistant() {
  echo "$ASSISTANT_ID" > "$LAST_ASSISTANT_FILE"
  echo "$ASSISTANT_NAME" >> "$LAST_ASSISTANT_FILE"
}

restore-selected-assistant() {
  local last_assistant

  if [ -f "$LAST_ASSISTANT_FILE" ]; then
    readarray -t last_assistant < "$LAST_ASSISTANT_FILE"

    if [ "${#last_assistant[@]}" -ne 2 ]; then
      rm "$LAST_ASSISTANT_FILE"
      touch "$LAST_ASSISTANT_FILE"
      return 0
    fi

    ASSISTANT_ID="${last_assistant[0]}"
    ASSISTANT_NAME="${last_assistant[1]}"
  fi
}

# ------------------------------------------------------------------------------
# The fun bit here is that I had GPT generate these messages. Meta AF, me.
# ------------------------------------------------------------------------------
# Initialize a global variable to store the last message index. Set to an invalid value initially.
LAST_MESSAGE_IDX=-1

get-random-polling-message() {
  local messages=(
    "Analyzing tensor matrices..."
    "Consulting with virtual neurons..."
    "Channeling the computational oracles..."
    "Calibrating language models..."
    "Propagating activations through the network..."
    "Optimizing synaptic connections virtually..."
    "Invoking the syntactic synthesis..."
    "Querying the knowledge graph..."
    "Counting electric sheep..."
    "Activating interlocks..."
    "Connecting dinotherms..."
    "Bringing up infracells..."
    "Megathrusters are go..."
    "Backfilling the quantum carburator..."
    "Bifurcating SchrÃ¶dinger's catscan..."
    "Reversing the polarity of the flux quantum..."
    "Reconfiguring the quantum plumbus..."
    "Raising crimson shields..."
    "Replacing dilithium crystals with new Folder's Crystals, let's see if engineering notices..."
    "Taking a break to watch some interdimensional cable..."
  )

  local idx
  local message_count=${#messages[@]}

  # Generate a random index, but ensure it's not the same as the last one
  while :; do
    idx=$((RANDOM % message_count))
    if [[ $idx -ne $LAST_MESSAGE_IDX ]]; then
      LAST_MESSAGE_IDX=$idx
      break
    fi
  done

  echo "${messages[$idx]}"
}

SPINNER_TMP_FILES=()
cleanup-spinner() {
  for temp_file in "${SPINNER_TMP_FILES[@]}"; do
    rm -f "$temp_file"
  done

  SPINNER_TMP_FILES=()
}

spinner() {
  local stdout
  local stderr
  local cmd_pid
  local cmd_exit_status

  stdout=$(mktemp)
  stderr=$(mktemp)
  SPINNER_TMP_FILES+=("$stdout" "$stderr")

  # Set trap to ensure cleanup runs on exit and interrupt
  trap cleanup-spinner EXIT INT TERM

  # Run the command in the background, redirecting stdout and stderr
  ("$@" > "$stdout" 2> "$stderr") &
  cmd_pid=$!

  # Poll for subprocess status
  while kill -0 "$cmd_pid" 2> /dev/null; do
    gum spin -s dot --title.foreground="#66FF66" --title "$(get-random-polling-message)" -- sleep 3
  done

  # Wait for the command to finish and capture its exit status
  wait "$cmd_pid"
  cmd_exit_status=$?

  # Output the command's stdout and stderr
  cat "$stdout"
  cat "$stderr" >&2

  # Remove the temporary files
  cleanup-spinner

  # Return the exit status of the command
  return $cmd_exit_status
}

# shellcheck disable=SC2317
run-thread-and-wait() {
  local result
  local run_id
  local status

  run_id=$(run-thread)

  while true; do
    status=$(get-run-status "$run_id")

    case "$status" in
      queued | in_progress)
        sleep 1
        continue
        ;;

      completed)
        return 0
        ;;

      *)
        warn "got unexpected status: not sure what to do"
        die "$result"
        ;;
    esac
  done
}

attach-file() {
  local filepath="${1:-}"
  local filename
  local message

  # If no argument provided, use file picker
  if [[ -z $filepath ]]; then
    filepath=$(gum filter --header 'Select a file to attach' --no-fuzzy --height 10) \
      || return 0
  fi

  # Ensure the file exists before proceeding
  if [[ ! -f $filepath ]]; then
    echo "File does not exist: $filepath" >&2
    return 0
  fi

  filename=$(basename "$filepath")
  filename_escaped=$(printf '%q' "$filename")
  message="Attached file: $filename_escaped\n\n\`\`\`$(< "$filepath")\`\`\`"

  send-msg "$message"
  print-user-msg "Attached file: $filename_escaped"
}

parse-message() {
  local message="$1"
  local is_in_code_fence=false
  local command_block=""
  local inside_command_block=false
  local parsed_lines=()

  while IFS= read -r line; do
    if [[ "$line" =~ ^\`\`\` ]]; then
      if $is_in_code_fence; then
        is_in_code_fence=false
      else
        is_in_code_fence=true
      fi
    elif ! $is_in_code_fence && [[ "$line" == \\begin ]]; then
      inside_command_block=true
      command_block=""
    elif ! $is_in_code_fence && [[ "$line" == \\end && $inside_command_block == true ]]; then
      inside_command_block=false
      if [[ -n $command_block ]]; then
        parsed_lines+=("EXEC $command_block")
      fi
      command_block=""
    elif $inside_command_block && [[ -n $line ]]; then
      if [[ "$line" =~ \\$ ]]; then
        command_block+="${line%\\} " # Append part of command, trimming the trailing backslash
      else
        command_block+="$line" # Regular line, just append
        if [[ $command_block =~ [^[:space:]] ]]; then
          parsed_lines+=("EXEC $command_block") # Only add if command_block is not just whitespace
        fi
        command_block=""
      fi
    elif ! $is_in_code_fence && [[ "$line" =~ ^\\exec\ (.*) ]]; then
      parsed_lines+=("EXEC ${BASH_REMATCH[1]}")
    else
      parsed_lines+=("TEXT $line")
    fi
  done <<< "$message"

  # Add any remaining non-empty commands to parsed_lines
  if [[ -n $command_block && $command_block =~ [^[:space:]] ]]; then
    parsed_lines+=("EXEC $command_block")
  fi

  printf "%s\n" "${parsed_lines[@]}"
}

handle-parsed-message() {
  local parsed_lines=("$@")
  local final_message=""
  local line

  for line in "${parsed_lines[@]}"; do
    if [[ "$line" =~ ^EXEC\ (.*) ]]; then
      local exec_line="${BASH_REMATCH[1]}"
      final_message+=$(attach-command-output "$exec_line")
    else
      local text_line="${line#TEXT }"
      final_message+="$text_line"$'\n'
    fi
  done

  # Print and send the final combined message.
  print-user-msg "$final_message"
  send-msg "$final_message"
}

attach-command-output() {
  local command="$1"
  local command_output
  local command_status

  # Execute the command and capture its output
  command_output=$(eval "$command" 2>&1)
  command_status=$?
  command_output=$(printf "\`\`\`sh\n\$ %s\n%s\n# exit status: %s\n\`\`\`" "$command" "$command_output" "$command_status")
  echo "$command_output"
}

chat() {
  local placeholder="ctrl-d submits | esc cancels | send \\f to attach a file | \\exec to embed 1-liner | \\begin..\\end to embed multi-line command"
  local needs_summary=false
  local initialized=false
  local msg

  # Come on, shellcheck, this is clearly a string, not an array. Seriously,
  # `read` operates just fine on here-strings.
  # shellcheck disable=SC2178
  local messages=""

  if [ -z "$ASSISTANT_ID" ]; then
    die "No assistant is selected"
  fi

  if [ -z "$THREAD_ID" ]; then
    die "No chat is selected"
  fi

  if [ "$THREAD_LABEL" == "New chat with $ASSISTANT_NAME" ]; then
    needs_summary=true
  fi

  while true; do
    if [ "$initialized" == false ]; then
      if [ "$THREAD_LABEL" != "New chat with $ASSISTANT_NAME" ]; then
        info "Retrieving conversation..."
        # shellcheck disable=SC2178
        messages="$(list-messages)"
        move-chat-to-beginning-of-history
        clear
      fi

      initialized=true
    else
      # shellcheck disable=SC2178
      messages="$(list-messages)"
    fi

    # shellcheck disable=SC2128
    while IFS= read -r line; do
      printf "%s\n" "$line"
    done <<< "$messages"

    while true; do
      echo
      msg=$(
        gum write \
          --width 140 \
          --height 15 \
          --char-limit 0 \
          --placeholder "$placeholder" \
          --header ">>> $THREAD_LABEL (id: $THREAD_ID) <<<" \
          --header.foreground="#66FF66" \
          --cursor.mode=static \
          || true
      )

      case "$msg" in
        '')
          break 2
          ;;

        '\f')
          attach-file
          continue
          ;;

        '\f '*)
          local file_path="${msg#\\f }"
          attach-file "$file_path"
          continue
          ;;

        '\resummarize')
          save-to-chat-history
          continue
          ;;

        *)
          IFS=$'\n' read -r -d '' -a parsed_lines < <(parse-message "$msg" && printf '\0')
          handle-parsed-message "${parsed_lines[@]}"
          spinner run-thread-and-wait

          if [ "$needs_summary" = true ]; then
            save-to-chat-history
            needs_summary=false
          fi

          break
          ;;

      esac
    done
  done
}

move-chat-to-beginning-of-history() {
  local temp_file
  local chat_entry

  temp_file=$(mktemp)
  chat_entry=$(grep "^$ASSISTANT_ID:$THREAD_ID:" "$CHAT_HISTORY_FILE")

  # Remove the existing chat entry, if any, from the chat history
  grep -v "^$ASSISTANT_ID:$THREAD_ID:" "$CHAT_HISTORY_FILE" > "$temp_file"

  # Add the chat entry to the "beginning" of the history file
  {
    cat "$temp_file"
    echo "$chat_entry"
  } > "$CHAT_HISTORY_FILE"

  # Clean up
  rm -f "$temp_file"
}

save-to-chat-history() {
  # goddamnit apple
  if [[ "$(uname)" == "Darwin" ]]; then
    SED_INPLACE_FLAG='-i ""'
  else
    SED_INPLACE_FLAG='-i'
  fi

  if grep "$ASSISTANT_ID:$THREAD_ID:" "$CHAT_HISTORY_FILE" > /dev/null; then
    eval "sed $SED_INPLACE_FLAG '/$ASSISTANT_ID:$THREAD_ID:/d' '$CHAT_HISTORY_FILE'"
  fi

  THREAD_LABEL=$(summarize-chat)
  printf '%s\n' "$ASSISTANT_ID:$THREAD_ID:$THREAD_LABEL" >> "$CHAT_HISTORY_FILE"
}

summarize-chat() {
  get-completion \
    'gpt-3.5-turbo-16k' \
    'You are a bot that summarizes conversations tersely' \
    "$(list-messages 6 false)\n\nSummarize the above conversation in 10 words or less"
}

new-chat() {
  THREAD_ID=$(start-thread)
  THREAD_LABEL="New chat with $ASSISTANT_NAME"
  MESSAGE_ID=""
  chat
}

list-chats() {
  local assistant_id
  local thread_id
  local label

  if [ -z "$ASSISTANT_ID" ]; then
    die "No assistant is selected"
  fi

  tac "$CHAT_HISTORY_FILE" | while IFS=':' read -r assistant_id thread_id label; do
    if [ "$assistant_id" == "$ASSISTANT_ID" ]; then
      echo -e "$label ($(gum style --faint "id: $thread_id"))"
    fi
  done
}

# ------------------------------------------------------------------------------
# Menus
# ------------------------------------------------------------------------------
assistant-menu() {
  local choices=()
  local header
  local selected

  while true; do
    clear
    choices=()

    while IFS=':' read -r id name; do
      choices+=("$name ($(gum style --faint "id: $id"))")
    done < <(list-assistants)

    choices+=("Create a new assistant")

    if [ -n "$ASSISTANT_ID" ]; then
      choices+=('Edit' 'Delete')
    fi

    choices+=("Back")

    header="Assistants"
    if [ -n "$ASSISTANT_ID" ]; then
      header="$header (selected: $ASSISTANT_NAME)"
    fi

    selected=$(gum choose --header "$header" "${choices[@]}") || return 0

    case "$selected" in
      "" | "Back")
        break
        ;;

      "Create a new assistant")
        add-assistant
        ;;

      "Edit")
        edit-assistant
        ;;

      "Delete")
        del-assistant
        ;;

      *)
        ASSISTANT_ID="$(echo "$selected" | sed -E 's/.*id: ([^)]+).*/\1/')"
        ASSISTANT_NAME="$(echo "$selected" | sed -E 's/^(.*) \(id: [^)]+\)$/\1/')"
        save-selected-assistant
        ;;
    esac
  done
}

chat-menu() {
  local choices=()
  local selected

  if [ -z "$ASSISTANT_ID" ]; then
    die "No assistant is selected"
  fi

  while true; do
    clear

    if grep "^$ASSISTANT_ID:" "$CHAT_HISTORY_FILE" > /dev/null; then
      choices=(
        "Start a new chat"
        "Continue a previous chat with $ASSISTANT_NAME"
        "Back"
      )

      selected=$(gum choose --header "Chats" "${choices[@]}") || true

      case "$selected" in
        "" | "Back")
          break
          ;;

        "Start a new chat")
          new-chat
          ;;

        "Continue a previous chat with $ASSISTANT_NAME")
          chat-history-menu
          ;;
      esac
    else
      new-chat
    fi
  done
}

chat-history-menu() {
  local choice
  local height
  local chats=()

  while true; do
    clear
    height=$(($(tput lines) - 2)) # -2 lines for gum filter's header and input

    chats=()
    while IFS= read -r line; do
      chats+=("$line")
    done < <(list-chats)

    if [ "${#chats[@]}" -eq 0 ]; then
      info 'No chat history found'
      read -r -p "Press enter to continue..." || true
      return 0
    fi

    choice=$(
      printf "%s\n" "${chats[@]}" \
        | gum filter \
          --header "Conversation history" \
          --placeholder "Search" \
          --no-fuzzy \
          --height "$height" \
        || true
    )

    if [ -n "$choice" ]; then
      THREAD_ID="$(echo "$choice" | sed -E 's/.*id: ([^)]+).*/\1/')"
      THREAD_LABEL="$(echo "$choice" | sed -E 's/^(.*) \(id: [^)]+\)$/\1/')"
      MESSAGE_ID=""
      chat
    else
      break
    fi
  done
}

main-menu() {
  local choices
  local selected

  while true; do
    clear

    choices=()
    if [ -n "$ASSISTANT_NAME" ]; then
      choices+=("Chat with $ASSISTANT_NAME")
    fi

    choices+=(
      "Assistants"
      "Quit"
    )

    selected=$(gum choose --header "What would you like to do?" "${choices[@]}") \
      || return 0

    case "$selected" in
      "")
        continue
        ;;

      "Assistants")
        assistant-menu
        ;;

      "Chat with $ASSISTANT_NAME")
        chat-menu
        ;;

      "Quit")
        return 0
        ;;
    esac
  done
}

validate-env

main-menu

exit 0
