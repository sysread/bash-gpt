#!/usr/bin/env perl

#-------------------------------------------------------------------------------
# TODO
#   - scrolling or somehow dealing with the buffer when it exceeds $HEIGHT lines
#   - what if the terminal is resized?
#-------------------------------------------------------------------------------

use strict;
use warnings;

use POSIX qw(:signal_h);

#-------------------------------------------------------------------------------
# Check for Term::ReadKey module and explain how to install it if it's missing.
#-------------------------------------------------------------------------------
BEGIN{
  eval{
    require Term::ReadKey;
    Term::ReadKey->import(qw(ReadKey ReadMode GetTerminalSize));
    1;
  } or do{
    my $error = $@;

    print "Unable to load Term::ReadKey module:\n\n$error\n\n";
    print "To install Term::ReadKey on your system, follow the instructions below:\n\n";

    if ($^O =~ /darwin/) {
      print "=== macOS Instructions ===\n";
      print "1. Install Homebrew (if not already installed) from https://brew.sh/\n";
      print "2. Install cpanminus (if not already installed):\n";
      print "   brew install cpanminus\n";
      print "3. Then run:\n";
      print "   cpanm -nq Term::ReadKey\n";
      print "==========================\n";
    } elsif ($^O =~ /linux/) {
      print "=== Linux Instructions ===\n";
      print "Ensure you have the necessary build tools installed. For example, on Debian-based systems:\n";
      print "1. Open a terminal and run:\n";
      print "   sudo apt-get update\n";
      print "   sudo apt-get install build-essential\n";
      print "   sudo apt-get install cpanminus\n";
      print "2. Then run:\n";
      print "   cpanm -nq Term::ReadKey\n";
      print "=========================\n";
    } else {
      print "Please refer to your operating system's package manager or documentation for installing the Term::ReadKey module.\n";
    }

    exit 1;
  };
}

#-------------------------------------------------------------------------------
# Globals
#-------------------------------------------------------------------------------
our $|         = 1;  # auto-flush STDOUT

our $DEBUG     = 1;

our $EOF       = \("EOF");
our $BACKSPACE = \("BACKSPACE");
our $UP        = \("UP");
our $DOWN      = \("DOWN");
our $LEFT      = \("LEFT");
our $RIGHT     = \("RIGHT");
our $NEWLINE   = \("NEWLINE");
our $ESCAPE    = \("ESCAPE");

our $BUFFER    = '';
our $OUTPUT    = '';
our $INDEX     = 0;
our $COL       = 0;
our $ROW       = 0;

our ($WIDTH, $HEIGHT) = GetTerminalSize;

# Open /dev/tty for reading and writing
open(our $TTY_IN, '<', '/dev/tty')  or die "Can't open /dev/tty for reading: $!";
open(our $TTY_OUT, '>', '/dev/tty') or die "Can't open /dev/tty for writing: $!";

END{
  close $TTY_IN;
  close $TTY_OUT;
}

# Set the terminal to cbreak mode, then restore it to normal mode when the
# program exits. This must happen before get_cursor_position() is called.
ReadMode 'cbreak', $TTY_IN;

END{
  ReadMode 'restore', $TTY_IN;
};

# Capture the initial cursor position
our ($START_ROW, $START_COL) = get_cursor_position();

#-------------------------------------------------------------------------------
# Debug
#-------------------------------------------------------------------------------
my $log;

if ($DEBUG) {
  open $log, '>', 'debug.log' or die $!;
  $log->autoflush(1);

  print $log qq{
--------------------------------------------------------------------------------
> Terminal size: $WIDTH x $HEIGHT
> Start position: $START_ROW, $START_COL
--------------------------------------------------------------------------------
};

  END{ close $log }
}

sub debug_msg {
  return unless $DEBUG;

  my $msg = shift;

  if (defined $msg) {
    print $log "> $msg\n";
  } else {
    print $log "\n";
  }
}

sub debug_pos {
  my $len = length $BUFFER;
  debug_msg "Index: $INDEX | Row: $ROW | Col: $COL | BufferLen: $len";
  debug_msg "Buffer: <<<\n$BUFFER\n>>>";
  debug_msg;
}

#-------------------------------------------------------------------------------
# Signal handlers
#-------------------------------------------------------------------------------
$SIG{INT}   = \&exit_failure;
$SIG{WINCH} = \&update_screen_dimensions;

#-------------------------------------------------------------------------------
# Exit handlers
#-------------------------------------------------------------------------------
sub exit_success {
  # Reset the cursor position to the start of the editable area if the script is
  # being run interactively.
  if (-t STDOUT) {
    clear_editable_area(*STDOUT);
  }

  # Print the output
  print "$OUTPUT\n";

  exit 0;
}

sub exit_failure {
  # Reset the cursor position to the start of the editable area if the script is
  # being run interactively.
  if (-t STDOUT) {
    clear_editable_area(*STDOUT);
    warn "cancelled\n";
  }

  exit 1;
}

#-------------------------------------------------------------------------------
# Movement and drawing
#-------------------------------------------------------------------------------
sub clamp {
  my ($min, $max, $val) = @_;
  return $min if $val < $min;
  return $max if $val > $max;
  return $val;
}

sub read_key {
  my $key = ReadKey 0, $TTY_IN;

  # Check for EOF
  return $EOF unless defined $key;

  my $ascii = ord $key;

  # Check for EOF (Ctrl-D)
  return $EOF if defined $key && $ascii == 4;

  # Check for Backspace
  return $BACKSPACE if $ascii == 8 || $ascii == 127;

  # Check for newline (Enter)
  return $NEWLINE if $key eq "\n";

  # Check for escape sequences (e.g., arrow keys)
  if ($key eq "\e") {
    # An escape sequence (that isn't the user hitting the escape key) will have
    # another key immediately following the escape character, and should be
    # immediately available. We can use a fractional read timeout to check for
    # this. If there is no other character immediately available, we can assume
    # the user just hit the escape key.
    my $next_key = ReadKey(0.1, $TTY_IN);

    if (defined $next_key && $next_key eq '[') {
      my $ctrl_key = ReadKey(0, $TTY_IN);

      if (defined $ctrl_key) {
        return $UP    if $ctrl_key eq 'A';
        return $DOWN  if $ctrl_key eq 'B';
        return $RIGHT if $ctrl_key eq 'C';
        return $LEFT  if $ctrl_key eq 'D';
      }
    }
    else {
      return $ESCAPE;
    }
  }

  # Return the key itself if it's not a special key
  return $key;
}

# Retrieve the index in the overall buffer at the beginning of the current row
sub start_index_of_row {
  my $idx  = 0;
  my $line = 0;
  my $max  = length $BUFFER;

  if ($ROW == 0) {
    return 0;
  }

  # Walk the buffer until we reach the desired row
  while ($line < $ROW && $idx < $max) {
    # Reached the end of a line
    if (substr($BUFFER, $idx, 1) eq "\n") {
      ++$line;
    }

    ++$idx;
  }

  return $idx;
}

sub last_col_in_current_line {
  my $idx = start_index_of_row;
  my $col = 0;

  # Walk through the buffer, starting from index $idx, until we reach
  # the end of the line, identified by either a newline (\n) or the end
  # of the buffer itself.
  while (substr($BUFFER, $idx, 1) ne "\n" && $idx < length $BUFFER) {
    ++$col;
    ++$idx;
  }

  return clamp(0, $WIDTH - 1, $col - 1);
}

sub num_rows_in_buffer {
  my $rows = 1;

  for (my $i = 0; $i < length $BUFFER; ++$i) {
    if (substr($BUFFER, $i, 1) eq "\n") {
      ++$rows;
    }
  }

  return $rows;
}

sub update_position_from_index {
  my $idx  = 0;
  my $line = 0;

  while ($idx < $INDEX) {
    if (substr($BUFFER, $idx, 1) eq "\n") {
      ++$line;
    }

    ++$idx;
  }

  $ROW = $line;
  $COL = $INDEX - start_index_of_row;
}

sub move_cursor_position {
  my ($row, $col, $fh) = @_;
  ++$row;
  ++$col;
  print $fh "\e[${row};${col}H";
}

sub clear_editable_area {
  my $fh = shift // $TTY_OUT;

  for (my $i = 0; $i < $HEIGHT; ++$i) {
    move_cursor_position($START_ROW + $i, 0, $fh);
    print $fh " " x $WIDTH;
  }

  # Move the cursor to the start position
  move_cursor_position($START_ROW, $START_COL, $fh);
}

sub redraw {
  # Clear the editable area only
  clear_editable_area($TTY_OUT);

  # Print the buffer
  print $TTY_OUT "$BUFFER";

  # Restore the cursor position
  move_cursor_position($START_ROW + $ROW, $START_COL + $COL, $TTY_OUT);

  debug_pos;
}

sub update_screen_dimensions {
  clear_editable_area($TTY_OUT);

  ($WIDTH, $HEIGHT) = GetTerminalSize;

  debug_msg "Terminal resized to $WIDTH x $HEIGHT";
  debug_pos;

  clear_editable_area($TTY_OUT);
  update_position_from_index();
  redraw();
}

sub up {
  # Already at the top of the buffer
  if ($ROW == 0) {
    return;
  }

  # Move up to the previous line
  --$ROW;

  # If the current line is shorter than the previous one, adjust the column
  my $last_col = last_col_in_current_line;

  if ($last_col < $COL) {
    $COL = $last_col;
    $INDEX = start_index_of_row + $COL;
  } else {
    $INDEX -= $COL + 1;  # Move the index to the end of the previous line
    $COL = last_col_in_current_line + 1;  # Adjust for insertion point
  }
}

sub down {
  my $num_rows = num_rows_in_buffer;
  my $last_index = $num_rows - 1;

  # Already at the bottom of the buffer
  if ($ROW == $last_index) {
    return;
  }

  # Move down to the next line
  ++$ROW;

  # If the current line is shorter than the next one, adjust the column
  my $last_col = last_col_in_current_line;

  if ($last_col < $COL) {
    $COL = $last_col;
    $INDEX = start_index_of_row + $COL;
  }
}

sub left {
  # Reached the beginning of the buffer
  if ($INDEX == 0) {
    return;
  }

  # Reached the beginning of the line
  if ($COL == 0) {
    --$ROW;

    $COL = last_col_in_current_line + 1;

    my $start_index = start_index_of_row;
    $INDEX = $start_index + $COL;

    return;
  }

  --$INDEX;
  --$COL;
}

sub right {
  # Reached the end of the buffer
  if ($INDEX == length $BUFFER) {
    return;
  }

  my $last_col = last_col_in_current_line;

  # Reached the end of the line
  if ($COL >= $last_col) {
    my $last_char_in_row = substr($BUFFER, $INDEX, 1);

    if ($last_char_in_row eq "\n") {
      ++$ROW;
      $COL = 0;
      $INDEX = start_index_of_row;
      return;
    }
  }

  ++$INDEX;
  ++$COL;
}

sub newline {
  # Insert a newline at the current index
  substr($BUFFER, $INDEX, 0, "\n");
  ++$INDEX;
  ++$ROW;
  $COL = 0;

  # Move the cursor to the next line
  $INDEX = start_index_of_row;
}

sub backspace {
  if ($INDEX > 0) {
    substr($BUFFER, $INDEX - 1, 1, '');
    --$INDEX;
    update_position_from_index;
  }
}

sub get_cursor_position {
  # Request cursor position
  print $TTY_OUT "\e[6n";

  # Read the response
  my $pos = do{ local $/ = 'R'; <STDIN> };

  # Parse out the row and column
  my ($row, $col) = $pos =~ /\e\[(\d+);(\d+)R/;

  # Adjust to 0-based index
  return ($row - 1, $col - 1);
}

#-------------------------------------------------------------------------------
# Read loop
#-------------------------------------------------------------------------------
while (1) {
  redraw;

  my $key = read_key;

  if ($key eq $EOF) {
    last;
  }

  if ($key eq $ESCAPE) {
    exit 1;
  }

  if ($key eq $NEWLINE) {
    $OUTPUT .= "\n";
    newline;
    next;
  }

  # backspace
  if ($key eq $BACKSPACE) {
    chop $OUTPUT;
    backspace;
    next;
  }

  # arrow keys
  if ($key eq $UP) {
    up;
    next;
  }

  if ($key eq $DOWN) {
    down;
    next;
  }

  if ($key eq $LEFT) {
    left;
    next;
  }

  if ($key eq $RIGHT) {
    right;
    next;
  }

  substr($BUFFER, $INDEX, 0, $key);
  ++$INDEX;
  ++$COL;

  # Wrap around to the next line if we reached the end of the current one
  if ($COL == $WIDTH) {
    ++$ROW;
    $COL = 0;
  }

  $OUTPUT .= $key;
}

exit_success;
