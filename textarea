#!/usr/bin/env perl

use strict;
use warnings;

use POSIX qw(:signal_h);

#-------------------------------------------------------------------------------
# Check for Term::ReadKey module and explain how to install it if it's missing.
#-------------------------------------------------------------------------------
BEGIN{
  eval{
    require Term::ReadKey;
    Term::ReadKey->import(qw(ReadKey ReadMode GetTerminalSize));
    1;
  } or do{
    my $error = $@;

    print "Unable to load Term::ReadKey module:\n\n$error\n\n";
    print "To install Term::ReadKey on your system, follow the instructions below:\n\n";

    if ($^O =~ /darwin/) {
      print "=== macOS Instructions ===\n";
      print "1. Install Homebrew (if not already installed) from https://brew.sh/\n";
      print "2. Install cpanminus (if not already installed):\n";
      print "   brew install cpanminus\n";
      print "3. Then run:\n";
      print "   cpanm -nq Term::ReadKey\n";
      print "==========================\n";
    } elsif ($^O =~ /linux/) {
      print "=== Linux Instructions ===\n";
      print "Ensure you have the necessary build tools installed. For example, on Debian-based systems:\n";
      print "1. Open a terminal and run:\n";
      print "   sudo apt-get update\n";
      print "   sudo apt-get install build-essential\n";
      print "   sudo apt-get install cpanminus\n";
      print "2. Then run:\n";
      print "   cpanm -nq Term::ReadKey\n";
      print "=========================\n";
    } else {
      print "Please refer to your operating system's package manager or documentation for installing the Term::ReadKey module.\n";
    }

    exit 1;
  };
}

#-------------------------------------------------------------------------------
# Globals
#-------------------------------------------------------------------------------
our $|             = 1;  # auto-flush STDOUT

our $DEBUG         = 1;

our $EOF           = \("EOF");
our $BACKSPACE     = \("BACKSPACE");
our $UP            = \("UP");
our $DOWN          = \("DOWN");
our $LEFT          = \("LEFT");
our $RIGHT         = \("RIGHT");
our $NEWLINE       = \("NEWLINE");
our $ESCAPE        = \("ESCAPE");
our $CTRL_A        = \("CTRL_A");
our $CTRL_E        = \("CTRL_E");

our $BUFFER        = '';
our $OUTPUT        = '';
our $INDEX         = 0;
our $COL           = 0;
our $ROW           = 0;
our $SCROLL_OFFSET = 0;

our ($WIDTH, $HEIGHT) = GetTerminalSize;

# Open /dev/tty for reading and writing
open(our $TTY_IN, '<', '/dev/tty')  or die "Can't open /dev/tty for reading: $!";
open(our $TTY_OUT, '>', '/dev/tty') or die "Can't open /dev/tty for writing: $!";

END{
  close $TTY_IN;
  close $TTY_OUT;
}

# Set the terminal to cbreak mode, then restore it to normal mode when the
# program exits. This must happen before get_cursor_position() is called.
ReadMode 'cbreak', $TTY_IN;

END{
  ReadMode 'restore', $TTY_IN;
};

# Capture the initial cursor position
our ($START_ROW, $START_COL) = get_cursor_position();

our $VISIBLE_LINES = $HEIGHT - $START_ROW;

#-------------------------------------------------------------------------------
# Debug
#-------------------------------------------------------------------------------
my $log;

if ($DEBUG) {
  open $log, '>', 'debug.log' or die $!;
  $log->autoflush(1);

  print $log qq{
--------------------------------------------------------------------------------
> Terminal size: $WIDTH x $HEIGHT
> Start position: $START_ROW, $START_COL
--------------------------------------------------------------------------------
};

  END{ close $log }
}

sub debug_msg {
  return unless $DEBUG;

  my $msg = shift;

  if (defined $msg) {
    print $log "> $msg\n";
  } else {
    print $log "\n";
  }
}

sub debug_pos {
  my $len = length $BUFFER;
  my $chr = substr $BUFFER, $INDEX, 1;
  my $ord = ord $chr;
  debug_msg;
  debug_msg "Visible lines: $VISIBLE_LINES | Scroll offset: $SCROLL_OFFSET";
  debug_msg "Index: $INDEX | Character: '$chr' | ASCII: $ord | Row: $ROW | Col: $COL | BufferLen: $len";
  debug_msg "Buffer: <<<\n$BUFFER\n>>>";
  debug_msg;
}

#-------------------------------------------------------------------------------
# Signal handlers
#-------------------------------------------------------------------------------
$SIG{INT}   = \&exit_failure;
$SIG{WINCH} = \&update_screen_dimensions;

#-------------------------------------------------------------------------------
# Exit handlers
#-------------------------------------------------------------------------------
sub exit_success {
  # Reset the cursor position to the start of the editable area if the script is
  # being run interactively.
  if (-t STDOUT) {
    clear_editable_area(*STDOUT);
  }

  # Print the output
  print "$OUTPUT\n";

  exit 0;
}

sub exit_failure {
  # Reset the cursor position to the start of the editable area if the script is
  # being run interactively.
  if (-t STDOUT) {
    clear_editable_area(*STDOUT);
    warn "cancelled\n";
  }

  exit 1;
}

#-------------------------------------------------------------------------------
# Movement and drawing
#-------------------------------------------------------------------------------
sub clamp {
  my ($min, $max, $val) = @_;
  return $min if $val < $min;
  return $max if $val > $max;
  return $val;
}

sub read_key {
  my $key = ReadKey 0, $TTY_IN;

  # Check for EOF
  return $EOF unless defined $key;

  my $ascii = ord $key;

  # Check for EOF (Ctrl-D)
  return $EOF if defined $key && $ascii == 4;

  # Check for Ctrl-E
  return $CTRL_E if $ascii == 5;

  # Check for Ctrl-A
  return $CTRL_A if $ascii == 1;

  # Check for Backspace
  return $BACKSPACE if $ascii == 8 || $ascii == 127;

  # Check for newline (Enter)
  return $NEWLINE if $key eq "\n";

  # Check for escape sequences (e.g., arrow keys)
  if ($key eq "\e") {
    # An escape sequence (that isn't the user hitting the escape key) will have
    # another key immediately following the escape character, and should be
    # immediately available. We can use a fractional read timeout to check for
    # this. If there is no other character immediately available, we can assume
    # the user just hit the escape key.
    my $next_key = ReadKey(0.1, $TTY_IN);

    if (defined $next_key && $next_key eq '[') {
      my $ctrl_key = ReadKey(0, $TTY_IN);

      if (defined $ctrl_key) {
        return $UP    if $ctrl_key eq 'A';
        return $DOWN  if $ctrl_key eq 'B';
        return $RIGHT if $ctrl_key eq 'C';
        return $LEFT  if $ctrl_key eq 'D';
      }
    }
    else {
      return $ESCAPE;
    }
  }

  # Return the key itself if it's not a special key
  return $key;
}

sub start_index_of_current_row {
  if ($ROW == 0) {
    return 0;
  }

  my $max = length($BUFFER);
  my $row = 0;
  my $col = 0;
  my $idx = 0;

  while ($idx < $max && $row < $ROW) {
    my $char = substr($BUFFER, $idx, 1);

    if ($char eq "\n") {
      # Move to next row
      ++$row;

      # Reset column
      $col = 0;

      # Index increments by 1 for the newline character and then another to
      # move to the first character on the next row.
      $idx += 2;
    }
    elsif (++$col >= $WIDTH) {
      # Move to next row
      ++$row;

      # Reset column
      $col = 0;

      # Index increments by 1 to move to the next row
      $idx += 1;
    }
    else {
      # Move to next character
      ++$idx;
    }
  }

  return $idx;
}

# Retrieve the index in the overall buffer at the beginning of the current row
sub start_index_of_row {
  my $idx  = 0;
  my $line = 0;
  my $col  = 0;
  my $max  = length $BUFFER;

  if ($ROW == 0) {
    return 0;
  }

  # Walk the buffer until we reach the desired row
  while ($line < $ROW && $idx < $max) {
    # Reached the end of a line
    if (substr($BUFFER, $idx, 1) eq "\n") {
      ++$line;
    }
    elsif ($col == $WIDTH) {
      ++$line;
      $col = 0;
    }
    else {
      ++$col;
    }

    ++$idx;
  }

  return $idx;
}

sub last_col_in_current_line {
  my $idx = start_index_of_current_row;
debug_msg("LAST_COL: line starts at:   $idx");

  # The last col in the line is either:
  #   - a newline
  #   - the end of the row (at $WIDTH - 1)
  #   - the end of the buffer
  my $newline = index $BUFFER, "\n", $idx;
debug_msg("LAST_COL: newline at index: $newline");

  # Newline found
  if ($newline != -1) {
    # If the newline is before WIDTH, then the last col is the newline
    if ($newline < $WIDTH) {
      return $newline - 1;
    }
    # If the newline is at or beyond WIDTH, then the last col is WIDTH - 1
    else {
      return $WIDTH - 1;
    }
  }
  # No newline was found
  else {
    # If there are more than WIDTH characters left in the buffer, then the last
    # col is WIDTH - 1.
    if (length($BUFFER) - $idx > $WIDTH) {
      return $WIDTH - 1;
    }
    else {
debug_msg "LAST_COL: " . length($BUFFER) . " - $idx - 1 = " . (length($BUFFER) - $idx - 1);
      return length($BUFFER) - $idx - 1;
    }
  }
}

sub num_rows_in_buffer {
  my $rows = 1;
  my $col  = 0;

  for (my $i = 0; $i < length $BUFFER; ++$i) {
    my $char = substr $BUFFER, $i, 1;

    if (++$col >= $WIDTH || $char eq "\n") {
      ++$rows;
      $col = 0;
    }
  }

  return $rows;
}

sub num_rows_in_buffer_old {
  my $rows = 1;

  for (my $i = 0; $i < length $BUFFER; ++$i) {
    if (substr($BUFFER, $i, 1) eq "\n") {
      ++$rows;
    }
  }

  return $rows;
}

sub update_position_from_index {
  my $idx = 0;
  my $row = 0;
  my $col = 0;

  while ($idx < $INDEX) {
    my $char = substr($BUFFER, $idx, 1);

    if ($char eq "\n") {
      # Move to next row
      ++$row;

      # Reset column
      $col = 0;

      # Index increments by 1 for the newline character and then another to
      # move to the first character on the next row.
      $idx += 2;
    }
    elsif (++$col >= $WIDTH) {
      # Move to next row
      ++$row;

      # Reset column
      $col = 0;

      # Index increments by 1 to move to the next row
      $idx += 1;
    }
    else {
      # Move to next character
      ++$idx;
    }
  }

  $ROW = $row;
  $COL = $col;
}

sub move_cursor_position {
  my ($row, $col, $fh) = @_;
  ++$row;
  ++$col;
  print $fh "\e[${row};${col}H";
}

sub clear_editable_area {
  my $fh = shift // $TTY_OUT;

  for (my $i = 0; $i < $VISIBLE_LINES; ++$i) {
    move_cursor_position($START_ROW + $i, 0, $fh);
    print $fh " " x $WIDTH;
  }

  # Move the cursor to the start position
  move_cursor_position($START_ROW, $START_COL, $fh);
}

sub split_buffer {
  my @lines;
  my $line   = '';
  my $length = 0;

  # Handle the case where $BUFFER is empty
  return @lines if !defined $BUFFER || $BUFFER eq '';

  for my $char (split //, $BUFFER) {
    if ($char eq "\n") {
      push @lines, $line;
      $line = '';
      $length = 0;
    }
    else {
      $line .= $char;
      $length++;

      if ($length == $WIDTH) {
        push @lines, $line;
        $line = '';
        $length = 0;
      }
    }
  }

  # Add the final line if it's not empty
  push @lines, $line if $line ne '';

  return @lines;
}

sub redraw {
  # Clear the editable area only
  clear_editable_area($TTY_OUT);

  # Print the buffer from the scroll offset
  my @lines = split_buffer;

  for (my $i = 0; $i < $VISIBLE_LINES && $i + $SCROLL_OFFSET < @lines; ++$i) {
    move_cursor_position($START_ROW + $i, 0, $TTY_OUT);
    print $TTY_OUT $lines[$i + $SCROLL_OFFSET];
  }

  # Restore the cursor position
  move_cursor_position($START_ROW + ($ROW - $SCROLL_OFFSET), $START_COL + $COL, $TTY_OUT);

  debug_pos;
}

sub update_screen_dimensions {
  clear_editable_area($TTY_OUT);

  ($WIDTH, $HEIGHT) = GetTerminalSize;
  $VISIBLE_LINES = $HEIGHT - 12;

  debug_msg "Terminal resized to $WIDTH x $HEIGHT";
  debug_pos;

  clear_editable_area($TTY_OUT);
  update_position_from_index();
  redraw();
}

sub up {
  # Already at the top of the buffer
  if ($ROW == 0) {
    return;
  }

  # Move up to the previous line
  --$ROW;

  # Scroll if necessary
  if ($ROW < $SCROLL_OFFSET) {
    --$SCROLL_OFFSET;
  }

  # Calculate the start index of the previous row
  my $start_index_of_row = start_index_of_current_row();
  my $row_length         = last_col_in_current_line() + 1; # Adjust for 0-based index

  # Adjust the column if the previous line is shorter
  if ($COL > $row_length) {
    $COL = $row_length;
  }

  $INDEX = $start_index_of_row + $COL;

  # Clamp the index to ensure it does not exceed the buffer length
  $INDEX = clamp(0, length($BUFFER), $INDEX);
  update_position_from_index();
}

sub down {
  # Calculate the total number of rows
  my $num_rows = num_rows_in_buffer;

  # Already at the bottom of the buffer
  if ($ROW >= $num_rows - 1) {
    return;
  }

  # Move down to the next line
  ++$ROW;

  # Scroll if necessary
  if ($ROW >= $SCROLL_OFFSET + $VISIBLE_LINES) {
    ++$SCROLL_OFFSET;
  }

  # Calculate the start index of the current row (that is, the next row, now
  # that we've incremented $ROW to move down one).
  my $start_index_of_row = start_index_of_current_row();
  my $row_length         = last_col_in_current_line() + 1; # Adjust for 0-based index

  # Adjust the column if the next line is shorter
  if ($COL > $row_length) {
    $COL = $row_length;
  }

  $INDEX = $start_index_of_row + $COL;

  # Clamp the index to ensure it does not exceed the buffer length
  $INDEX = clamp(0, length($BUFFER), $INDEX);
  update_position_from_index();
}

sub left {
  # Reached the beginning of the buffer
  if ($INDEX == 0) {
    return;
  }

  # Reached the beginning of the line
  if ($COL == 0) {
    --$ROW;

    $COL = last_col_in_current_line + 1;

    my $start_index = start_index_of_row;
    $INDEX = $start_index + $COL;

    return;
  }

  --$INDEX;
  --$COL;
}

sub right {
  # Reached the end of the buffer
  if ($INDEX >= length $BUFFER) {
    return;
  }

  my $last_col  = last_col_in_current_line;
  my $next_char = substr $BUFFER, $INDEX + 1, 1;

  # Reached the end of the line
  if ($COL >= $last_col || $next_char eq "\n") {
    $COL = 0;
    ++$ROW;
    ++$INDEX;
    return;
  }

  ++$INDEX;
  ++$COL;

  # Clamp the index to ensure it does not exceed the buffer length
  $INDEX = clamp(0, length($BUFFER), $INDEX);
}

sub newline {
  # Insert a newline at the current index
  substr($BUFFER, $INDEX, 0, "\n");
  ++$INDEX;
  ++$ROW;
  $COL = 0;

  # Scroll if necessary
  if ($ROW >= $SCROLL_OFFSET + $VISIBLE_LINES) {
    ++$SCROLL_OFFSET;
  }

  # Move the cursor to the next line
  $INDEX = start_index_of_row;
}

sub backspace {
  if ($INDEX > 0) {
    substr($BUFFER, $INDEX - 1, 1, '');
    --$INDEX;
    update_position_from_index;
  }
}

sub ctrl_a {
  $COL = 0;
  $INDEX = start_index_of_row;
}

sub ctrl_e {
  $COL = last_col_in_current_line;
  $INDEX = start_index_of_row + $COL;
}

sub get_cursor_position {
  # Request cursor position
  print $TTY_OUT "\e[6n";

  # Read the response
  my $pos = do{ local $/ = 'R'; <STDIN> };

  # Parse out the row and column
  my ($row, $col) = $pos =~ /\e\[(\d+);(\d+)R/;

  # Adjust to 0-based index
  return ($row - 1, $col - 1);
}

#-------------------------------------------------------------------------------
# Read loop
#-------------------------------------------------------------------------------
while (1) {
  redraw;

  my $key = read_key;

  if ($key eq $EOF) {
    debug_msg 'EOF';
    last;
  }

  if ($key eq $ESCAPE) {
    debug_msg 'ESCAPE';
    exit 1;
  }

  if ($key eq $NEWLINE) {
    debug_msg 'NEWLINE';
    $OUTPUT .= "\n";
    newline;
    next;
  }

  # backspace
  if ($key eq $BACKSPACE) {
    debug_msg 'BACKSPACE';
    chop $OUTPUT;
    backspace;
    next;
  }

  # arrow keys
  if ($key eq $UP) {
    debug_msg 'UP';
    up;
    next;
  }

  if ($key eq $DOWN) {
    debug_msg 'DOWN';
    down;
    next;
  }

  if ($key eq $LEFT) {
    debug_msg 'LEFT';
    left;
    next;
  }

  if ($key eq $RIGHT) {
    debug_msg 'RIGHT';
    right;
    next;
  }

  # Ctrl-A
  if ($key eq $CTRL_A) {
    debug_msg 'CTRL-A';
    ctrl_a;
    next;
  }

  # Ctrl-E
  if ($key eq $CTRL_E) {
    debug_msg 'CTRL-E';
    ctrl_e;
    next;
  }

  debug_msg "KEY: $key";

  substr($BUFFER, $INDEX, 0, $key);
  ++$INDEX;
  ++$COL;

  # Wrap around to the next line if we reached the end of the current one
  if ($COL == $WIDTH) {
    ++$ROW;
    $COL = 0;
  }

  if ($key eq "\n") {
    ++$ROW;
    $COL = 0;
  }

  $OUTPUT .= $key;
}

exit_success;
